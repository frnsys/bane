Usage Guide
===========

Here's a handy guide to help outline exactly how all of this works.

## Setting it up ##
First, clone the repo:
``` bash
$ git clone https://github.com/ftzeng/bane.git
```

Then change into the directory and run the setup script:
``` bash
$ cd bane
$ ./powerup.sh
```

Or, if you're lazy, here's the whole thing in one line:
``` bash
$ git clone https://github.com/ftzeng/bane.git && cd bane && ./powerup.sh
```

Then, you will probably want to run the [Grunt](http://gruntjs.com/)
`watch` task, which is the default task:
``` bash
$ grunt
```
This will automatically compile your Jade templates and Sass stylesheets
as they change. You can modify this task in `Gruntfile.js`.

More conveniently, you can use the `summon.sh` script, like so:
``` bash
$ source ./summon.sh
```

This is just a little bit more convenient and opens up a new tab with
the site in it.


## Directory Structure ##
BBBane.ed (★Backbone Boilerplate Bane edition★) has the following
directory structure, with the example project:
```
├── Gruntfile.js
├── app
│   ├── app.js
│   ├── config.js
│   ├── main.js
│   ├── modules
│   │   └── (your modules)
│   ├── router.js
│   ├── styles
│   │   └── (stylesheets, based off Atomic)
│   ├── templates
│   │   ├── some_module
│   │   │   └── (module templates)
│   │   └── main.jade
│   └── templates.js
├── assets
│   └── images
├── data
│   └── (dummy JSON data)
├── favicon.ico
├── index.html
├── package.json
├── powerup.sh
├── source
│   ├── icons
│   │   └── (SVG source files)
│   └── images
│   		└── (PSDs, AIs, etc)
└── vendor
    ├── jam
    │   └── (jam packages)
    └── js
        └── libs
            └── (other js libs)
```

## Main Logic ##
 
`main.js`  
Here is where the application kicks off. `app.js` and `router.js` are
loaded, and then the Router created in `router.js` is instantiated and
attached to your `app`.  
Backbone's history is setup. In our case, we're using hash urls instead
of the HTML5 history API. Using "true" urls requires some special
handling on the server, and in our prototyping use case it's nice if we
can just use a simple HTTP server (see below on how).

This file also specifies a binding for links in the document, hijacking
relative links (i.e. links on the same site) so they use the app's
router instead of their normal behavior.
Specifying a `data-bypass` attribute on the element will override this
binding.

  
`app.js`  
Here is where you can load in any additional JS packages and configure
your `app` object, such as setting what the root url is.
This is also where `LayoutManager` is setup and where template fetching is
handled.

  
`router.js`  
This is where the navigation interaction is handled. You load your `app`
here and your `modules` as well. Routes are created here as well.

  
`config.js`  
This is what RequireJS loads first (as specified in `index.html`) and
loads Jam's RequireJS config (thereby loading your core packages) and
then loading `main.js`.

## Modules ##

`modules/`  
Here is the meat-and-potatoes of your app. Modules are logical units
representing the entities in your application. Things that 'belong
together' should be wrapped up in a module, which would encompass
the relevant model(s), view(s), and collection(s).  
You load these modules into `router.js`.

## Templates ##

`templates/`  
Templates are stored here. Bane uses
[Jade](http://jade-lang.com/) as its templating engine, and
expects `.jade` as template extensions. You should try to group them
according to module, though you are not held to these rules.

## Styling ##

`styles/`  
Bane is using my Atomic CSS microframework as a submodule. It's still a
work in progress and is meant to reflect my own style defaults, so you
may want to swap this out with something more appropriate for yourself.

If you decide to stick with my framework, you can edit `_atomic.scss` to
configure Atomic, such as colors/type and what modules to use, and to
paste in icon classes generated by [Font Custom](http://fontcustom.com/)
(see below).  
In `index.scss` you can place the rest of your styles.


## Data ##

`data/`  
Place dummy data in here as `json` files. Specify your `collection` urls
to point to the appropriate files here. This allows your prototype to
feel a little more 'real'.

## Assets ##

`source/`  
Place asset source files in here, such as SVGs for building icon fonts,
or PSDs for raster graphic assets.

## Libraries & Packages & Plugins ##

`vendor`  
Third-party packages are placed in here, such as those installed by Jam
(in `vendor/jam/`), or those you install yourself (in `vendor/js/`, for
example).

## Misc ##

`package.json`  
Specify your app's dependencies and other information here.  
This is also where Jam's directories are specified.


## Helpful Goodies ##

### A simple HTTP server ###
This is available in [DippinDots](https://github.com/ftzeng/dippindots),
my dotfiles. This particular function is from [Mathias Bynen's
Dotfiles](https://github.com/mathiasbynens/dotfiles/blob/master/.functions).

If you have Python installed, you can add the following to your
`~/.bash_profile` to make it very easy to quickly get a basic HTTP
server running.

``` bash
function server() {
	local port="${1:-8000}"
		sleep 1 && open "http://localhost:${port}/" &
		python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
}
```

Then reload your `.bash_profile` with:
```
$ source ~/.bash_profile
```

And now you can just run:
```
$ server
```

### Font Custom ###
[Font Custom](http://fontcustom.com/) is an awesome tool that allows you
to build your own icon fonts from SVG files.

Here's how to install it on OSX.  
You will need [Homebrew](http://mxcl.github.io/homebrew/), which can be
installed by running the following command:
``` bash
$ ruby -e "$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)"
```

Then, to install Font Custom:
``` bash
$ brew install fontforge ttfautohint
$ gem install fontcustom
```
See the [Font Custom](http://fontcustom.com/) site for Linux installation instructions.

If you're storing your icon SVGs in `source/icons/`, you can run the
following command from your application root to compile the SVGs into an
icon webfont:
``` bash
$ fontcustom compile source/icons
```

This will generate a css file and the webfont files. The webfont files
should go into `app/styles/fonts/` and should be renamed to
`icons.(extension)`, that is `icons` plus the existing extension. The
`.icon-` classes specifying the character codes for the icons should be
ported into `app/styles/_config.scss` (if you're using Atomic).  
At some point I will try to create a script to automate this process.


### Grunt ###
[Grunt](http://gruntjs.com/) is an essential automation tool. It will
perform a set of preconfigured tasks for you, which you define in
`Gruntfile.js`.

Bane's default task can be initialized with:
``` bash
$ grunt
```
in Bane's root directory.

This will start watching the project files for any changes, and
automatically compile Jade and Sass files. It will also run a server on
port 8989, providing access to the project (i.e.
		`http://localhost:8989`).

If you are not running the native app version of
[LiveReload](http://livereload.com/), you can
optionally uncomment the `livereload: true` configuration line in the
Gruntfile to start a LiveReload server as well. To use it, install the
[LiveReload Chrome
extensions](https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei),
so that your site will automatically refresh on file change.

You can easily augment Grunt to your own liking with its [vast set of
plugins](http://gruntjs.com/plugins).
